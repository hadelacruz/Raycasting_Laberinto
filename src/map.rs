pub struct Map {
    pub grid: Vec<Vec<u8>>, 
    pub start: (f32, f32),
    pub end: (usize, usize),
}

impl Map {
    pub fn new() -> Self {
        // Laberinto
        let grid = vec![
            vec![1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            vec![1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,1],
            vec![1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1,0,1],
            vec![1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1],
            vec![1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1],
            vec![1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,1],
            vec![1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,1,0,1],
            vec![1,0,1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,1],
            vec![1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1],
            vec![1,0,1,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1],
            vec![1,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,1],
            vec![1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
            vec![1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        ];
        let start = (1.5, 1.5); // Entrada 
        let end = (9, 11);    // Salida (Meta)
        Self { grid, start, end }
    }
    pub fn is_wall(&self, x: usize, y: usize) -> bool {
        self.grid.get(y).and_then(|row| row.get(x)).copied().unwrap_or(1) != 0
    }
} 